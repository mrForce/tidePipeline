"""Adding columns for whether or not it is part of an iterative search

Revision ID: ebf98eb0c77e
Revises: 98a6ad0ea1f1
Create Date: 2018-08-10 12:06:50.737243

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'ebf98eb0c77e'
down_revision = '98a6ad0ea1f1'
branch_labels = None
depends_on = None


def upgrade():
    metadata = sa.MetaData()
    connection = op.get_bind()
    # ### commands auto generated by Alembic - please adjust! ###
    searchbase = sa.Table('SearchBase', metadata, sa.Column('idSearch', sa.Integer, primary_key=True), sa.Column('searchType', sa.String(50)), sa.Column('SearchName', sa.String, unique=True), sa.Column('partOfIterativeSearch', sa.Boolean, default=False))
    filteredsearchresult = sa.Table('FilteredSearchResult', metadata, sa.Column('idFilteredSearchResult', sa.Integer, primary_key=True), sa.Column('filteredSearchResultName', sa.String, unique=True), sa.Column('idQValueBase', sa.Integer), sa.Column('partOfIterativeSearch', sa.Boolean, default=False))
    qvaluebase = sa.Table('QValueBase', metadata, sa.Column('idQValue', sa.Integer, primary_key=True), sa.Column('QValueType', sa.String(50)), sa.Column('idSearchBase', sa.Integer, sa.ForeignKey('SearchBase.idSearch')), sa.Column('partOfIterativeSearch', sa.Boolean, default=False))


    mgfFile = sa.Table('MGFfile', metadata, sa.Column('idMGFfile', sa.Integer, primary_key=True), sa.Column('MGFName', sa.String, unique=True), sa.Column('partOfIterativeSearch', sa.Boolean, default=False))
    
    op.add_column('FilteredSearchResult', sa.Column('partOfIterativeSearch', sa.Boolean(), nullable=True))
    
        
    op.add_column('QValueBase', sa.Column('partOfIterativeSearch', sa.Boolean(), nullable=True))

    op.add_column('SearchBase', sa.Column('partOfIterativeSearch', sa.Boolean(), nullable=True))

    op.add_column('MGFfile', sa.Column('partOfIterativeSearch', sa.Boolean(), nullable=True))
    for row in connection.execute(sa.select([mgfFile])):
        if ('largetosmall' in row.MGFName.lower()) or ('smalltolarge' in row.MGFName.lower()):
            connection.execute(mgfFile.update().where(mgfFile.c.idMGFfile == row.idMGFfile).values(partOfIterativeSearch=True))
    for row in connection.execute(sa.select([searchbase])):
        if ('largetosmall' in row.SearchName.lower()) or ('smalltolarge' in row.SearchName.lower()):
            for qvalue_row in connection.execute(sa.select([qvaluebase]).where(qvaluebase.c.idSearchBase == row.idSearch)):
                connection.execute(qvaluebase.update().where(qvaluebase.c.idQValue == qvalue_row.idQValue).values(partOfIterativeSearch = True))
                for filteredsearch_row in connection.execute(sa.select([filteredsearchresult]).where(filteredsearchresult.c.idQValueBase == qvalue_row.idQValue)):
                    connection.execute(filteredsearchresult.update().where(filteredsearchresult.c.idFilteredSearchResult == filteredsearch_row.idFilteredSearchResult).values(partOfIterativeSearch=True))
            connection.execute(searchbase.update().where(searchbase.c.idSearch == row.idSearch).values(partOfIterativeSearch = True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('SearchBase', 'partOfIterativeSearch')
    op.drop_column('QValueBase', 'partOfIterativeSearch')
    op.drop_column('FilteredSearchResult', 'partOfIterativeSearch')
    # ### end Alembic commands ###
